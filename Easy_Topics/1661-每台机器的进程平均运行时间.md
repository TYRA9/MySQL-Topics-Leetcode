#### **No.1661-每台机器的进程平均运行时间**:
1. **力扣链接**：https://leetcode.cn/problems/average-time-of-process-per-machine/description/
2. **题目说明**
    - //todo
3. **答案**（纯代码）： 
      
    ```sql
    # Write your MySQL query statement below    
        -- The key is that GROUP BY does not physically 
        -- "squeeze" or destroy the individual rows before 
        -- AVG sees them. Instead, GROUP BY logically 
        -- partitions the intermediate result set into 
        -- groups. The AVG function then operates on all 
        -- the values within each of these logical partitions.
        
    # Method One : INNER JOIN (显式内连接)
    SELECT
        `A1`.`machine_id`,
        ROUND(AVG(`A2`.`timestamp` - `A1`.`timestamp`), 3) AS `processing_time`
    FROM 
        `Activity` AS `A1`
    INNER JOIN
        `Activity` AS `A2` 
    ON 
        `A1`.`machine_id` = `A2`.`machine_id` AND
        `A1`.`process_id` = `A2`.`process_id` AND
        `A1`.`activity_type` = 'start' AND
        `A2`.`activity_type` = 'end'
    GROUP BY
        `A1`.`machine_id`;


    # ------------------------------
    # Method Two: 多表查询（隐式自连接）
    SELECT 
        `a1`.`machine_id`,
        ROUND(AVG(`a2`.`timestamp` - `a1`.`timestamp`), 3) AS `processing_time`
    FROM
        `Activity` AS `a1`, `Activity` AS `a2`
    WHERE 
        `a1`.`machine_id` = `a2`.`machine_id` 
    AND 
        `a1`.`process_id` = `a2`.`process_id`
    AND
        `a1`.`activity_type` = 'start'
    AND 
        `a2`.`activity_type` = 'end'
    GROUP BY
        `a1`.`machine_id`;


    # ------------------------------
    # Method Three: Single Pass Aggregation (单次聚合)
    SELECT
        `machine_id`,
        ROUND(
            SUM(IF(`activity_type` = 'start', -1 * `timestamp`, 1 * `timestamp`)) / COUNT(DISTINCT process_id), 3
        ) AS `processing_time`
    FROM
        `Activity`
    GROUP BY
        `machine_id`;
    ```
4. **思路及解析**：
    - //todo